

create or replace stage manage_db.external_stages.jsonstage
  url='s3://23devyani/'
  credentials=(aws_key_id='Aws key'
  aws_secret_key='secerate key');


create or replace file format manage_db.file_formats.jsonformat
 type =JSON;

 describe file format manage_db.file_formats.jsonformat type = json;

 create or replace table our_first_db.public.json_raw (raw_file variant);

 -- variant datatype- flexible, universal datatype which can store any type data 

copy into our_first_db.public.json_raw from 
  @manage_db.external_stages.jsonstage
  file_format= manage_db.file_formats.jsonformat
  files = ('HR.json');


select * from our_first_db.public.json_raw;

select raw_file:city, raw_file:job from our_first_db.public.json_raw; -- yaha hame data me se city attribute nikalana hai / same isi cheez ko hum doller $ se v access kar sakte hai 
-- raw file ko hi $1 bhi likh sakte hai , jab data key: value pair me ho to use colon (:)
-- se hi access karte hai ! 

select $1:first_name from our_first_db.public.json_raw;

-- hme dekhna hmara data string format h ya int or change karna hai

select raw_file:first_name,raw_file:first_name::string as col from our_first_db.public.json_raw;

select 
 raw_file:id::int as id,
 raw_file:first_name::string as first_name,
 raw_file:last_name::string as gender 
 from our_first_db.public.json_raw;

 
// handling nested data 
select raw_file:job as job, raw_file:job:salary::int from  our_first_db.public.json_raw;

select raw_file:job as job, raw_file:job:title::string from  our_first_db.public.json_raw;

// both ways are correct
// when we use nested condition then we use dot (.) // use dot to access child atribute
// : is used for high level highrarchy while . is used to nested attributes 
select raw_file:job as job, raw_file:job.salary::int from  our_first_db.public.json_raw;

// one more tarika for access nested data or one or more attribute 
select 
 raw_file:job:salary::int,raw_file['job']['salary'] as salary from our_first_db.public.json_raw;

 // handling arrays
 select raw_file:prev_company as prev_company from our_first_db.public.json_raw ;

select raw_file:prev_company[1]::string as prev_company , 
ARRAY_SIZE(raw_file:prev_company) from our_first_db.public.json_raw;


select 
 raw_file:id::int as id,
 raw_file:first_name::string as first_name,
 raw_file:prev_company[0] :: string as prev_company 
 from our_first_db.public.json_raw
 union
 select
  raw_file:id::int as id,
 raw_file:first_name::string as first_name,
 raw_file:prev_company[1] :: string as prev_company 
 from our_first_db.public.json_raw order by id;



select * from our_first_db.public.json_raw;

select raw_file:first_name as fname , raw_file:spoken_languages,
raw_file:spoken_languages[0]['language'] from our_first_db.public.json_raw
union 
select raw_file:first_name as fname , raw_file:spoken_languages,
raw_file:spoken_languages[1]['language'] from our_first_db.public.json_raw order by fname;


-- it will create a object for every json
-- for the language json the language will be divided again and again

select raw_file:first_name, raw_file:spoken_languages,
value, value:language from
our_first_db.public.json_raw,lateral flatten(input=>raw_file:spoken_languages);